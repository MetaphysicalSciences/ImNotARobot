<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Extreme CPU & GPU Stress Test</title>
<style>
  body { margin: 0; overflow: hidden; background: black; color: white; font-family: monospace; }
  #stats { position: absolute; top: 0; left: 0; padding: 10px; background: rgba(0,0,0,0.5); }
  canvas { display: block; }
</style>
</head>
<body>
<div id="stats">Initializing...</div>
<canvas id="glcanvas"></canvas>

<script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const statsEl = document.getElementById('stats');
let fps = 0, frames = 0, last = performance.now();
let memory = {usedJSHeapSize: 0, totalJSHeapSize: 0};

function updateStats() {
    const now = performance.now();
    frames++;
    if (now - last >= 1000) {
        fps = frames;
        frames = 0;
        last = now;
        if (performance.memory) {
            memory.usedJSHeapSize = performance.memory.usedJSHeapSize;
            memory.totalJSHeapSize = performance.memory.totalJSHeapSize;
        }
        statsEl.textContent = `
FPS: ${fps}
JS Heap: ${(memory.usedJSHeapSize/1048576).toFixed(2)}MB / ${(memory.totalJSHeapSize/1048576).toFixed(2)}MB
Canvas: ${canvas.width}x${canvas.height}
Particle Count: ${particles.length}
        `;
    }
}

// ---- GPU Stress ----
const particleCount = 50000000000000; // increase for more stress
const particles = new Float32Array(particleCount * 3);
for (let i=0;i<particleCount*3;i++) {
    particles[i] = (Math.random()*2-1) * 1;
}

const vertexShaderSource = `
attribute vec3 position;
uniform float time;
void main() {
    vec3 pos = position;
    pos.x += sin(time + pos.y*10.0)*0.01;
    pos.y += cos(time + pos.x*10.0)*0.01;
    gl_PointSize = 1.5;
    gl_Position = vec4(pos,1.0);
}
`;

const fragmentShaderSource = `
precision mediump float;
void main() {
    gl_FragColor = vec4(1.0,0.2,0.5,1.0);
}
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(shader));
    }
    return shader;
}

const vs = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fs = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
gl.useProgram(program);

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, particles, gl.DYNAMIC_DRAW);

const positionLoc = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc,3,gl.FLOAT,false,0,0);

const timeLoc = gl.getUniformLocation(program,'time');

// ---- CPU Stress ----
function heavyCalculation() {
    const size = 2000000000000000; 
    const matrix = [];
    for(let i=0;i<size;i++){
        matrix[i] = [];
        for(let j=0;j<size;j++){
            matrix[i][j] = Math.sin(i*j) * Math.cos(i+j);
        }
    }
    return matrix;
}

function animate(time){
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform1f(timeLoc, time*0.001);
    gl.drawArrays(gl.POINTS,0,particleCount);

    heavyCalculation(); // CPU heavy
    
    updateStats();
    requestAnimationFrame(animate);
}

animate(0);

</script>
</body>
</html>

